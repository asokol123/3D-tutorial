# Особенности C++
Как-то упорядочить их сложно, поэтому будет неупорядоченный список.

## Линковка
Библиотеки можно собрать как статические, так и динамические.

При использовании статические библиотеки встраиваются в исполняемый файл, а динамические подгружаются только если они нужны и экономят размер исполяемого файла.

Однако у динамических библиотек есть огромный недостаток: в разных системах они могут быть несовместимы, поэтому распространение динамически слинкованного исполняемого файла - огромная проблема. Эта проблема так же известна как [DLL Hell](https://ru.wikipedia.org/wiki/DLL_hell)

Современные языки такие как `Go` и `Rust` по умолчанию используют статическую линковку, и аналогично я рекомендую использовать ее пока нет острой потребности в динамеческой.

## Обработка ошибок
Основной механизм обработки ошибок в `C++` - исключения. Исключения в `C++` непроверяемые.

Основная проблема непроверяемых исключений - никогда нельзя сказать, откуда может вылететь исключение и какое. Самый простой и популярный способ решения этого - ловить исключения только в `main`, логировать это и завершаться.

Другая важная особенность исключений - их можно применять только в исключительных, редких ситуаций. Если ошибки частые, то исключения - плохая практика.

Кроме исключений в `C++` хорошего способа обработки ошибок нет. В `Rust` для обработки ошибок используется специальный класс `Result` в качестве возвращаемого значения. Это одновременно решает и то, что непонятно откуда может вылететь исключение, и производительность при частых исключениях.

Частой проблемой использования классов наподобии `Result` для обработки ошибок являются замусоривающие код проверки как в `Go`:
```go
result, err := some_func()
if err != nil {
    return nil, err
}
```
В `Rust` с этим все проще:
```rust
let result = some_func()?
```
`?` сам пробрасывает ошибку наверх если надо.

В `C++` ожидается в 23 стандарте `std::expected` и уже есть [сторонные библиотеки](https://github.com/TartanLlama/expected), его реализующие. Так же есть интересный проект [couroutine monad](https://github.com/toby-allsopp/coroutine_monad).

## Атрибут `[[nodiscard]]`
В нашей реализации мы не стали делать свои классы для точки, а использовали вместо этого `Eigen::Vector4d`. Одной из проблем такого подхода что мы не можем сделать нужные нам методы для точки.

Так нормализацию пришлось делать не методом, а функцией, и писать `Normalize(p)` вместо `p.Normalize()`. Проблема таких функций и методов - непонятно сразу, возвращают они измененное значение, или меняют старое.

Есть конвенция называть `Normalize` если функция меняет данный ей объект и `Normalized` если функция возвращает новый объект. Однако чтобы программист не перепутал и забыл использовать возвращенное значение из функции, полагая что она меняет ее аргумент, есть [атрибут `[[nodiscard]]`](https://en.cppreference.com/w/cpp/language/attributes/nodiscard)

Этот атрибут запрещает игнорировать результат функции:
```cpp
auto f1(int arg) -> int;
[[nodiscard]] auto f2(int arg) -> int;
...
int x = 0;
f1(x); // OK
f2(x); // Warning
```

## Proxy object
При реализации многомерных массивов возникает вопрос как обеспечить доступ к элементам. Есть несколько популярных способов:

1. `arr(i1, i2)`
2. `arr[i1][i2]`
3. `arr[{i1, i2}]`

Третий хороший идейно: исползовать специальный объект для двумерной индексации, но неудобен в использовании.

Первый удобен в написании, но также не совсем всегда удобен в использовании.