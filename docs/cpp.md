# Особенности C++
Как-то упорядочить их сложно, поэтому будет неупорядоченный список.

## Линковка
Библиотеки можно собрать как статические, так и динамические.

При использовании статические библиотеки встраиваются в исполняемый файл, а динамические подгружаются только если они нужны и экономят размер исполяемого файла.

Однако у динамических библиотек есть огромный недостаток: в разных системах они могут быть несовместимы, поэтому распространение динамически слинкованного исполняемого файла - огромная проблема. Эта проблема так же известна как [DLL Hell](https://ru.wikipedia.org/wiki/DLL_hell)

Современные языки такие как `Go` и `Rust` по умолчанию используют статическую линковку, и аналогично я рекомендую использовать ее пока нет острой потребности в динамеческой.

## Обработка ошибок
Основной механизм обработки ошибок в `C++` - исключения. Исключения в `C++` непроверяемые.

Основная проблема непроверяемых исключений - никогда нельзя сказать, откуда может вылететь исключение и какое. Самый простой и популярный способ решения этого - ловить исключения только в `main`, логировать это и завершаться.

Другая важная особенность исключений - их можно применять только в исключительных, редких ситуаций. Если ошибки частые, то исключения - плохая практика.

Кроме исключений в `C++` хорошего способа обработки ошибок нет. В `Rust` для обработки ошибок используется специальный класс `Result` в качестве возвращаемого значения. Это одновременно решает и то, что непонятно откуда может вылететь исключение, и производительность при частых исключениях.

Частой проблемой использования классов наподобии `Result` для обработки ошибок являются замусоривающие код проверки как в `Go`:
```go
result, err := some_func()
if err != nil {
    return nil, err
}
```
В `Rust` с этим все проще:
```rust
let result = some_func()?
```
`?` сам пробрасывает ошибку наверх если надо.

В `C++` ожидается в 23 стандарте `std::expected` и уже есть [сторонные библиотеки](https://github.com/TartanLlama/expected), его реализующие. Так же есть интересный проект [couroutine monad](https://github.com/toby-allsopp/coroutine_monad).

## Атрибут `[[nodiscard]]`
В нашей реализации мы не стали делать свои классы для точки, а использовали вместо этого `Eigen::Vector4d`. Одной из проблем такого подхода что мы не можем сделать нужные нам методы для точки.

Так нормализацию пришлось делать не методом, а функцией, и писать `Normalize(p)` вместо `p.Normalize()`. Проблема таких функций и методов - непонятно сразу, возвращают они измененное значение, или меняют старое.

Есть конвенция называть `Normalize` если функция меняет данный ей объект и `Normalized` если функция возвращает новый объект. Однако чтобы программист не перепутал и забыл использовать возвращенное значение из функции, полагая что она меняет ее аргумент, есть [атрибут `[[nodiscard]]`](https://en.cppreference.com/w/cpp/language/attributes/nodiscard)

Этот атрибут запрещает игнорировать результат функции:
```cpp
auto f1(int arg) -> int;
[[nodiscard]] auto f2(int arg) -> int;
...
int x = 0;
f1(x); // OK
f2(x); // Warning
```

## Proxy object-ы и времена жизни
При реализации многомерных массивов возникает вопрос как обеспечить доступ к элементам. Есть несколько популярных способов:

1. `arr(i1, i2)`
2. `arr[i1][i2]`
3. `arr[{i1, i2}]`

Третий хороший идейно: исползовать специальный объект для двумерной индексации, но неудобен в использовании.

Первый удобен в написании, но также не совсем всегда удобен в использовании.

Второй самый удобный в использовании, однако он неочевиден в написании, рассмотрим подробнее его реализацию и способы отстрелить ногу.

Как правило такое обращение реализовывают с помощью специальных `Proxy`-объектов: `arr[i1]` возвращает объект, хранящий в себе ссылку на `arr` и `i1`. В нашем случае так же можно просто держать ссылку на начало строки в данных.

Какие есть проблемы такого подхода:

`Proxy`-объект держит ссылку на `arr`. И ничто не может гарантировать что он переживет `arr`, после чего будет доступ к уже умершему объекту `arr`.

Несколько примеров, которые на первый взгляд не вызывают подозрений, и с которыми я сталкивался даже в реальной практике:

```C++
template <typename T>
auto GetRow(const std::vector<std::vector<T>>& arr) {
    return arr[0]; // OK
}

// Делаем аналогичную функцию для нашего массива
template <typename T>
auto GetRow(const Plain2DArray<T>& arr) {
    return arr[0]; // Bad
}
```

Аналогичная проблема в целом распространена в `C++`, и на работе я с ней сталкивался неоднократно. Пример из реального проекта:

```C++
// library.h
class Parser {
public:
    Item* Parse();

private:
    Item item;
};

// main.cpp
auto PraseAndCheck() {
    Parser parser;
    auto item = parser.Parse();
    if (item == nullptr) {
        throw std::runtime_error();
    }
    return item;
}
```

И компилятор не выдает никаких предупреждение, только при запуске под санитайзерами можно отловить проблемы.

Таким образом проблема что объект может пережить то, на что он ссылается, в `C++` есть всегда. Так же достаточно часто это встречается при работе с `std::string_view`

Универсального решения для такой проблемы нет. `Go` решает ее с помощью сборщика мусора, но это существенные накладные расходы.

`Rust` решает ее с помощью введения `lifetime`-ов объектов и проверки их на этапе компиляции.

## Сигнатуры функций
Это скорее про стиль кода, а не про функциональность.

По умолчанию в `C++` функции объявляются таким образом:
```
ТипРезультата ИмяФункции(ТипПараметра1 ИмяПараметра1, ...) {

}
```
Таким образом сначала мы видим что функция возвращает и лишь потом что принимает.

Большинство современных языков выбрали другой путь:

`Kotlin`:
```kotlin
fun ParseInt(line: String): Int {}
```
`Go`:
```go
func ParseInt(line string) (int, error) {}
```
`Rust`:
```rust
fn parse_int(line: &str) -> Result<i32, Error> {}
```
`Swift`:
```swift
func parse_int(line: String) -> Int {
```

Таким образом возвращаемое значение в конце функции в современном мире привычнее и лучше читается.

Другой плюс - есть доступ к параметрам функции:
```C++
auto Begin(auto x) -> decltype(x.begin());
```

## Move семантика
`Move`-семантика - крайне полезная вщеь, появившаяся в `C++11`. Она позволяет как оптимизировать код, так и лучше обеспечивать инварианты кода.

Суть `move`-семантики проста - значения можно не копировать, а перемещать. Например для копирования `std::vector` необходимо скопировать все данные, а для перемещения необходимо просто изменить 6 указателей. \texttt{move}-семантика автоматически используется для временных объектов и возврате объектов из функции.

Так же она позволяет реализовывать функции и методы, которые поглощают объект, т.е. после использования которых объект переходит в некорректное состояние. Для этого в `C++` есть `ref qualifier`. Он позволяет использовать метод только на `rvalue`, и для его вызова явно придется писать:
```C++
std::move(obj).method();
```
После этого с помощью внешних утилит для проверки кода, таких как `clang-tidy` можно убедиться что этот объект не будет использоваться.

Однако у move-семантики в C++ есть две проблемы:
* Почти всегда нужно явно писать `std::move`. Про это очень легко забыть, и многие программисты это намеренно не делают.
* move-конструктор может выкинуть исключение. Поэтому не всегда можно именно переместить объект, а приходится копировать, например при увеличении размера в `std::vector`

Хорошим сравнением тут выступает `Rust`: в нем все по умолчанию перемещается и перемещение это всегда просто копирование содержимого объекта. И нет проблем ни с забытым `std::move`, ни с исключениями из `move`-конструктора.
